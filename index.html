<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Metro Doom v4.0.2</title>
    <style>
        body { 
            margin: 0; padding: 0; overflow: hidden; background: #000; 
            font-family: 'Courier New', monospace; 
            user-select: none; -webkit-touch-callout: none; -webkit-user-select: none;
            touch-action: none; width: 100vw; height: 100vh;
        }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }
        
        #blood-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 4;
            box-shadow: inset 0 0 100px 50px rgba(200, 0, 0, 0.9);
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.4) 90%);
            opacity: 0; transition: opacity 0.1s;
            mix-blend-mode: multiply;
        }

        #ui {
            position: absolute; top: env(safe-area-inset-top, 20px); left: 20px; 
            color: #0f0; font-size: 16px; text-shadow: 1px 1px #000; pointer-events: none; z-index: 5;
            display: none;
        }

        /* --- HOTBAR (Minecraft Style) --- */
        #hotbar-container {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; z-index: 15; pointer-events: auto;
        }
        .slot {
            width: 50px; height: 50px; background: rgba(0,0,0,0.6);
            border: 3px solid #555; border-radius: 4px; position: relative;
            display: flex; justify-content: center; align-items: center;
            color: white; font-weight: bold; font-size: 12px; cursor: pointer;
            transition: transform 0.1s;
        }
        .slot.active { border-color: white; background: rgba(100,100,100,0.5); transform: scale(1.1); box-shadow: 0 0 10px white; }
        .slot-num { position: absolute; top: 2px; left: 4px; font-size: 10px; color: #ccc; }
        .slot-ammo { position: absolute; bottom: 2px; right: 4px; font-size: 10px; color: #ff0; }
        
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); 
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; z-index: 10;
            backdrop-filter: blur(5px); padding: 20px; box-sizing: border-box;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 8vh; color: #d00; text-shadow: 0 0 15px red; margin: 0 0 10px 0; text-align: center; text-transform: uppercase;}
        p { font-size: 16px; color: #ccc; margin: 5px; text-align: center;}
        
        .btn-container { display: flex; flex-direction: column; gap: 10px; width: 100%; align-items: center; }
        
        button {
            padding: 12px 0; font-size: 18px; background: rgba(34, 34, 34, 0.9);
            color: #fff; border: 2px solid #555; cursor: pointer; 
            font-family: 'Courier New', monospace; width: 80%; max-width: 350px; border-radius: 8px;
        }
        button:active { background: #d00; transform: scale(0.98); }
        
        #map-btn { border-color: cyan; color: cyan; margin-bottom: 10px; }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20; display: none;
        }
        .mob-btn {
            position: absolute; border-radius: 50%; 
            background: rgba(200, 200, 200, 0.15); border: 2px solid rgba(255,255,255,0.2);
            color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
            pointer-events: auto; touch-action: none; backdrop-filter: blur(2px);
        }
        .mob-btn:active { background: rgba(255, 255, 255, 0.3); border-color: white; }

        #joystick-zone {
            position: absolute; bottom: 90px; left: 40px; width: 100px; height: 100px;
            background: rgba(255,255,255,0.05); border-radius: 50%; border: 1px dashed rgba(255,255,255,0.2);
            pointer-events: auto;
        }
        #joystick-knob {
            position: absolute; top: 25px; left: 25px; width: 50px; height: 50px;
            background: rgba(0, 255, 255, 0.4); border-radius: 50%; pointer-events: none;
        }

        #btn-fire { bottom: 90px; right: 30px; width: 80px; height: 80px; background: rgba(255, 50, 50, 0.25); border-color: #f55; font-size: 14px; }
        .mini-btn { width: 50px; height: 50px; font-size: 16px; }
        #btn-reload { bottom: 180px; right: 30px; }
        #btn-bomb { bottom: 180px; right: 90px; border-color: orange; color: orange; }
        #btn-pause-mob { top: env(safe-area-inset-top, 20px); right: 20px; width: 40px; height: 40px; font-size: 18px; border-radius: 8px; }

        /* --- VERSION & ADMIN --- */
        #version-label {
            position: absolute; bottom: 10px; right: 10px; color: #555; font-size: 14px; 
            cursor: pointer; z-index: 100;
        }

        #password-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 10000;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #pass-input { padding: 10px; font-size: 20px; margin-bottom: 10px; background: #222; color: #0f0; border: 1px solid #0f0; }
        
        #admin-menu {
            position: absolute; top: 50px; left: 50px; width: 280px;
            background: rgba(0, 20, 0, 0.95); border: 2px solid #0f0;
            z-index: 9999; color: #0f0; padding: 0; display: flex; flex-direction: column;
            box-shadow: 0 0 20px #0f0; font-size: 12px;
        }
        #admin-header {
            background: #0f0; color: black; padding: 5px; text-align: center; 
            font-weight: bold; cursor: move; touch-action: none;
        }
        .admin-tabs { display: flex; border-bottom: 1px solid #0f0; }
        .admin-tab { flex: 1; padding: 8px; text-align: center; cursor: pointer; background: #000; color: #050; }
        .admin-tab.active { background: #030; color: #0f0; font-weight: bold; }

        #admin-body { padding: 10px; display: flex; flex-direction: column; gap: 8px; }
        .admin-btn { width: 100%; font-size: 12px; padding: 6px; border-color: #0f0; background: #000; color: #0f0; }
        .admin-input { width: 95%; background: #000; color: #fff; border: 1px solid #555; margin-bottom: 2px; }
        .admin-row { display: flex; justify-content: space-between; align-items: center; }
    </style>
</head>
<body>

<input type="file" id="loadFileBtn" style="display:none" accept=".json">
<div id="blood-screen"></div>

<div id="password-modal" class="hidden">
    <h2 style="color:#0f0">–í–í–ï–î–ò–¢–ï –ü–ê–†–û–õ–¨</h2>
    <input type="password" id="pass-input" placeholder="–ü–∞—Ä–æ–ª—å">
    <button onclick="checkAdminPass()" style="width: 200px;">–í–û–ô–¢–ò</button>
    <button onclick="closePassModal()" style="width: 200px; margin-top:10px; border-color:#555;">–û–¢–ú–ï–ù–ê</button>
</div>

<div id="admin-menu" class="hidden">
    <div id="admin-header">ADMIN TOOLS v4.0.2</div>
    <div class="admin-tabs">
        <div class="admin-tab active" onclick="switchTab('MAIN')">–ì–õ–ê–í–ù–ê–Ø</div>
        <div class="admin-tab" onclick="switchTab('CLONE')">–ö–õ–û–ù</div>
    </div>
    
    <div id="tab-main" class="admin-content">
        <div id="admin-body">
            <button class="admin-btn" onclick="giveAdminGun()">1. –ê–î–ú–ò–ù –ì–ê–ù</button>
            <div class="admin-row">
                <span>GOD MODE:</span>
                <button id="god-btn" class="admin-btn" style="width:60px" onclick="toggleGod()">OFF</button>
            </div>
            <div class="admin-row">
                <span>SPEED:</span>
                <input type="range" min="3" max="20" value="5" onchange="changeSpeed(this.value)" style="width:100px">
            </div>
            <hr style="width:100%; border:0; border-top:1px solid #0f0;">
            <div class="admin-row">
                <span>WAVE:</span>
                <input type="number" id="admin-wave-in" value="1" class="admin-input" style="width:50px">
                <button class="admin-btn" style="width:50px" onclick="setWave()">SET</button>
            </div>
            <hr style="width:100%; border:0; border-top:1px solid #0f0;">
            <div style="font-size:10px;">–°–ü–ê–í–ù –ú–û–ù–°–¢–†–ê:</div>
            <input type="number" id="admin-hp" class="admin-input" placeholder="HP" value="100">
            <select id="admin-type" class="admin-input">
                <option value="green">–ó–µ–ª–µ–Ω—ã–π</option>
                <option value="red">–ö—Ä–∞—Å–Ω—ã–π</option>
                <option value="purple">–§–∏–æ–ª–µ—Ç–æ–≤—ã–π</option>
            </select>
            <button class="admin-btn" onclick="spawnAdminEnemy()">–°–ü–ê–í–ù–ò–¢–¨</button>
            <button class="admin-btn" onclick="killAllEnemies()">KILL ALL</button>
            <button class="admin-btn" onclick="toggleEsp()">ESP (WH)</button>
            <button class="admin-btn" onclick="toggleAdminMenu()" style="border-color:red; color:red">–ó–ê–ö–†–´–¢–¨</button>
        </div>
    </div>

    <div id="tab-clone" class="admin-content hidden">
        <div id="admin-body">
            <div>–£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–õ–û–ù–û–ú (MAX 1)</div>
            <button class="admin-btn" onclick="spawnClone()">–°–û–ó–î–ê–¢–¨ –ö–õ–û–ù–ê</button>
            <hr style="width:100%; border:0; border-top:1px solid #0f0;">
            <div>–•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ò:</div>
            <div class="admin-row">
                <span>–¶–≤–µ—Ç:</span>
                <input type="color" id="clone-col" value="#00ffff" onchange="updateCloneStats()">
            </div>
            <div class="admin-row">
                <span>–£—Ä–æ–Ω:</span>
                <input type="number" id="clone-dmg" value="10" style="width:50px" onchange="updateCloneStats()">
            </div>
            <button class="admin-btn" onclick="removeClone()" style="border-color:orange; color:orange">–£–î–ê–õ–ò–¢–¨ –ö–õ–û–ù–ê</button>
        </div>
    </div>
</div>

<div id="ui">
    <div>HP: <span id="hp-val">100</span>%</div>
    <div id="wave-ui">WAVE: <span id="wave-val">1</span></div>
    <div id="goal-ui" class="hidden">KILLS: <span id="kill-val">0</span> / 100</div>
    <div id="enemy-stat">–í–†–ê–ì–ò: <span id="enemies-left">0</span></div>
</div>

<div id="hotbar-container"></div>

<div id="mobile-controls">
    <div id="joystick-zone"><div id="joystick-knob"></div></div>
    <div id="btn-fire" class="mob-btn">–ê–í–¢–û<br>–û–ì–û–ù–¨</div>
    <div id="btn-reload" class="mob-btn mini-btn">R</div>
    <div id="btn-bomb" class="mob-btn mini-btn">C4</div>
    <div id="btn-pause-mob" class="mob-btn" onclick="togglePause()">||</div>
</div>

<div id="menu" class="screen">
    <h1>METRO DOOM</h1>
    <p>–ë–æ—Ç –∑–∞—á–∏—â–∞–µ—Ç —Å–µ–∫—Ç–æ—Ä...</p>
    <div class="btn-container">
        <button id="map-btn" onclick="toggleMap()">–ö–ê–†–¢–ê: –ì–û–†–û–î</button>
        <button onclick="initGame('CLASSIC')">–ö–õ–ê–°–°–ò–ö–ê</button>
        <button onclick="initGame('100_ENEMIES')">100 –ú–û–ù–°–¢–†–û–í</button>
        <button onclick="initGame('HARDCORE')">–•–ê–†–î–ö–û–† (1 HP)</button>
        <button onclick="initGame('FISTS')">–¢–û–õ–¨–ö–û –ö–£–õ–ê–ö–ò</button>
    </div>
    <div id="version-label" onclick="versionClick()">v4.0.2 beta</div>
</div>

<div id="pauseMenu" class="screen hidden">
    <h1>–ü–ê–£–ó–ê</h1>
    <div class="btn-container">
        <button onclick="togglePause()">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
        <button id="btn-save" onclick="saveGame()">–°–û–•–†–ê–ù–ò–¢–¨</button>
        <button id="btn-load" onclick="triggerLoad()">–ó–ê–ì–†–£–ó–ò–¢–¨</button>
        <button onclick="location.reload()">–í–´–ô–¢–ò</button>
    </div>
</div>

<div id="gameOver" class="screen hidden">
    <h1>–¢–´ –ü–û–ì–ò–ë</h1>
    <p>–£–±–∏—Ç–æ: <span id="final-kills">0</span></p>
    <button onclick="location.reload()">–í –ú–ï–ù–Æ</button>
</div>

<div id="victory" class="screen hidden">
    <h2>–ü–û–ë–ï–î–ê!</h2>
    <p>–°–µ–∫—Ç–æ—Ä –∑–∞—á–∏—â–µ–Ω.</p>
    <button onclick="location.reload()">–í –ú–ï–ù–Æ</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
window.onload = function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ú–ê–°–®–¢–ê–ë–ê –ù–ê –ú–û–ë–ò–õ–¨–ù–´–• ---
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    // –¢–µ–ø–µ—Ä—å –º–∞—Å—à—Ç–∞–± –±–ª–∏–∂–µ –∫ –ü–ö (0.9 –≤–º–µ—Å—Ç–æ 0.7), –Ω–æ –∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π
    let mobileScale = isMobile ? 0.9 : 1.0; 

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    if(isMobile) {
        document.getElementById('mobile-controls').style.display = 'block';
    }

    const WORLD_W = 2500;
    const WORLD_H = 1500;
    
    // --- –î–ê–ù–ù–´–ï –ö–ê–†–¢ ---
    let currentMapKey = 'CITY'; 
    const MAPS = {
        'METRO': {
            name: "–ú–ï–¢–†–û",
            spawn: { x: 300, y: 1200 },
            bg: '#151515',
            ground: [],
            walls: [
                {x: -100, y: -100, w: WORLD_W + 200, h: 100, c:'#111'}, 
                {x: -100, y: WORLD_H, w: WORLD_W + 200, h: 100, c:'#111'},
                {x: -100, y: 0, w: 100, h: WORLD_H, c:'#111'}, {x: WORLD_W, y: 0, w: 100, h: WORLD_H, c:'#111'},
                {x: 400, y: 200, w: 100, h: 100, c:'#333'}, {x: 1000, y: 200, w: 100, h: 100, c:'#333'},
                {x: 1600, y: 200, w: 100, h: 100, c:'#333'}, {x: 2200, y: 200, w: 100, h: 100, c:'#333'},
                {x: 400, y: 1200, w: 100, h: 100, c:'#333'}, {x: 1000, y: 1200, w: 100, h: 100, c:'#333'},
                {x: 150, y: 150, w: 20, h: 300, c:'#222'}, {x: 150, y: 150, w: 300, h: 20, c:'#222'}
            ]
        },
        'CITY': {
            name: "–ì–û–†–û–î",
            spawn: { x: 1250, y: 750 },
            bg: '#335533', 
            ground: [
                {x: 0, y: 650, w: 2500, h: 200, c: '#444'},
                {x: 1150, y: 0, w: 200, h: 1500, c: '#444'},
            ],
            walls: [
                {x: -100, y: -100, w: WORLD_W + 200, h: 100, c:'#000'}, 
                {x: -100, y: WORLD_H, w: WORLD_W + 200, h: 100, c:'#000'},
                {x: -100, y: 0, w: 100, h: WORLD_H, c:'#000'}, {x: WORLD_W, y: 0, w: 100, h: WORLD_H, c:'#000'},
                {x: 200, y: 100, w: 20, h: 300, c:'#a55'},  {x: 600, y: 100, w: 20, h: 300, c:'#a55'},
                {x: 200, y: 100, w: 420, h: 20, c:'#a55'}, {x: 200, y: 400, w: 150, h: 20, c:'#a55'}, {x: 450, y: 400, w: 170, h: 20, c:'#a55'},
                {x: 1600, y: 100, w: 20, h: 400, c:'#336'}, {x: 2000, y: 100, w: 20, h: 400, c:'#336'},
                {x: 1600, y: 100, w: 420, h: 20, c:'#336'}, {x: 1600, y: 500, w: 150, h: 20, c:'#336'}, {x: 1850, y: 500, w: 170, h: 20, c:'#336'},
                {x: 300, y: 1000, w: 20, h: 300, c:'#654'}, {x: 700, y: 1000, w: 20, h: 300, c:'#654'},
                {x: 300, y: 1300, w: 420, h: 20, c:'#654'}, {x: 300, y: 1000, w: 150, h: 20, c:'#654'}, {x: 550, y: 1000, w: 170, h: 20, c:'#654'},
                {x: 1700, y: 1000, w: 20, h: 300, c:'#555'}, {x: 2200, y: 1000, w: 20, h: 300, c:'#555'},
                {x: 1700, y: 1300, w: 520, h: 20, c:'#555'}, {x: 1700, y: 1000, w: 200, h: 20, c:'#555'}, {x: 2000, y: 1000, w: 220, h: 20, c:'#555'},
                {x: 1450, y: 300, w: 50, h: 50, c:'#222'}, {x: 1000, y: 800, w: 50, h: 50, c:'#222'}, {x: 1450, y: 1200, w: 100, h: 20, c:'#222'} 
            ]
        }
    };
    let currentWalls = MAPS['CITY'].walls;

    // --- –ü–ï–†–ï–ú–ï–ù–ù–´–ï –ò–ì–†–´ ---
    let camera = { x: 0, y: 0 };
    let gameState = 'MENU';
    let isDemo = true;
    let gameMode = 'CLASSIC';
    let frame = 0;
    let score = 0;
    let wave = 1;
    let totalKills = 0;
    let hitEffectTimer = 0;

    let player = {
        x: 300, y: WORLD_H - 300, radius: 20, speed: 5, hp: 100, maxHp: 100, angle: 0,
        weaponIndex: 0, reloading: false, reloadTimer: 0, reloadMax: 0
    };
    let godMode = false;

    // –ò–°–ü–†–ê–í–õ–ï–ù–´ –•–ê–†–ê–ö–¢–ï–†–ò–°–¢–ò–ö–ò –û–†–£–ñ–ò–Ø
    // range —É –±–ª–∏–∂–Ω–µ–≥–æ –±–æ—è —É–≤–µ–ª–∏—á–µ–Ω –¥–ª—è —Ñ–∏–∫—Å–∞
    // –¥—Ä–æ–±–æ–≤–∏–∫ –±–∞—Ñ—Ñ–Ω—É—Ç (–±–æ–ª—å—à–µ –¥—Ä–æ–±–∏, –±–æ–ª—å—à–µ —É—Ä–æ–Ω)
    let weapons = []; 
    const ALL_WEAPONS = [
        { name: "–î–†–û–ë–û–í–ò–ö", type: 'gun', dmg: 20, delay: 55, ammo: 8, max: 8, rld: 120, count: 8, spread: 0.25, range: 450, col: 'orange', icon: 'üî´' }, 
        { name: "–ü–ò–°–¢–û–õ–ï–¢", type: 'gun', dmg: 25, delay: 18, ammo: 12, max: 12, rld: 60, count: 1, spread: 0.05, range: 650, col: 'yellow', icon: 'ü§è' }, 
        { name: "–ö–£–õ–ê–ö–ò",   type: 'melee', dmg: 20, delay: 20, ammo: Infinity, max: 0, rld: 0, range: 80, col: 'white', icon: 'üëä' }, 
        { name: "–ù–û–ñ",      type: 'melee', dmg: 45, delay: 15, ammo: Infinity, max: 0, rld: 0, range: 90, col: '#aaa', icon: 'üî™' },  
        { name: "–£–ó–ò",      type: 'gun', dmg: 10, delay: 5,  ammo: 35, max: 35, rld: 90, count: 1, spread: 0.15, range: 500, col: 'cyan', icon: 'üñäÔ∏è' },
        { name: "C4 –ë–û–ú–ë–ê", type: 'placeable', dmg: 200, delay: 30, ammo: 10, max: 10, rld: 0, range: 200, col: '#f33', icon: 'üí£' }
    ];

    let bullets = [];
    let enemies = [];
    let particles = [];
    let items = [];
    let placedBombs = [];
    
    // –ö–ª–æ–Ω
    let clone = { active: false, x: 0, y: 0, angle: 0, target: null, timer: 0, col: '#00ffff', dmg: 10 };
    
    let train = { active: false, y: WORLD_H / 2 - 70, height: 140, x: -3000, speed: 35, warning: false, timer: 0 };

    const keys = {};
    const mouse = { x: 0, y: 0, down: false };

    // --- –ê–î–ú–ò–ù –ü–ï–†–ï–ú–ï–ù–ù–´–ï ---
    let versionClicks = 0;
    let adminEsp = false;

    window.versionClick = function() {
        versionClicks++;
        if (versionClicks >= 6) {
            versionClicks = 0;
            document.getElementById('password-modal').classList.remove('hidden');
        }
    };

    window.closePassModal = function() {
        document.getElementById('password-modal').classList.add('hidden');
    };

    window.checkAdminPass = function() {
        const pass = document.getElementById('pass-input').value;
        if (pass === 'vuntraq27') {
            document.getElementById('password-modal').classList.add('hidden');
            document.getElementById('admin-menu').classList.remove('hidden');
        } else {
            alert("–ù–ï–í–ï–†–ù–´–ô –ü–ê–†–û–õ–¨");
        }
    };

    window.toggleAdminMenu = function() {
        document.getElementById('admin-menu').classList.toggle('hidden');
    };

    window.switchTab = function(tab) {
        document.getElementById('tab-main').classList.add('hidden');
        document.getElementById('tab-clone').classList.add('hidden');
        document.querySelectorAll('.admin-tab').forEach(t => t.classList.remove('active'));
        
        if (tab === 'MAIN') {
            document.getElementById('tab-main').classList.remove('hidden');
            document.querySelectorAll('.admin-tab')[0].classList.add('active');
        } else {
            document.getElementById('tab-clone').classList.remove('hidden');
            document.querySelectorAll('.admin-tab')[1].classList.add('active');
        }
    };

    // –§–£–ù–ö–¶–ò–ò –ê–î–ú–ò–ù–ê
    window.giveAdminGun = function() {
        let adminGun = { 
            name: "ADMIN GUN", type: 'gun', dmg: 100, delay: 2, 
            ammo: Infinity, max: 999, rld: 0, count: 1, spread: 0.1, range: 1500, col: '#0f0', icon: 'üòà' 
        };
        weapons.push(adminGun);
        createHotbar();
        player.weaponIndex = weapons.length - 1;
        updateUI();
    };

    window.toggleGod = function() {
        godMode = !godMode;
        document.getElementById('god-btn').innerText = godMode ? "ON" : "OFF";
        document.getElementById('god-btn').style.color = godMode ? "#0f0" : "#555";
    };

    window.changeSpeed = function(val) {
        player.speed = parseInt(val);
    };

    window.setWave = function() {
        wave = parseInt(document.getElementById('admin-wave-in').value);
        enemies = []; // –û—á–∏—Å—Ç–∫–∞ —Ç–µ–∫—É—â–µ–π –≤–æ–ª–Ω—ã
        spawnWave();
        updateUI();
    };

    window.spawnAdminEnemy = function() {
        let hp = parseInt(document.getElementById('admin-hp').value) || 100;
        let type = document.getElementById('admin-type').value;
        spawnSpecificEnemy(type, hp);
    };

    function spawnSpecificEnemy(type, hp) {
        let sx = player.x + (Math.random()-0.5)*400;
        let sy = player.y + (Math.random()-0.5)*400;
        let e = { x: sx, y: sy, vx: 0, vy: 0, maxHp: hp, hp: hp };
        if (type === 'green') { e.c='#0c0'; e.s=2; e.r=25; e.dmg=0.8; }
        else if (type === 'red') { e.c='#f00'; e.s=5.5; e.r=14; e.dmg=0.4; }
        else { e.c='#a0a'; e.s=3.5; e.r=18; e.dmg=0.5; }
        enemies.push(e);
        updateUI();
    }

    window.killAllEnemies = function() {
        enemies.forEach(e => { spawnParticles(e.x, e.y, 15, '#000'); score += 15; totalKills++; });
        enemies = [];
        updateUI();
    };

    window.toggleEsp = function() { adminEsp = !adminEsp; };

    // CLONE FUNCTIONS
    window.spawnClone = function() {
        if (clone.active) return;
        clone.active = true;
        clone.x = player.x; clone.y = player.y;
        updateCloneStats();
    };

    window.removeClone = function() { clone.active = false; };

    window.updateCloneStats = function() {
        clone.col = document.getElementById('clone-col').value;
        clone.dmg = parseInt(document.getElementById('clone-dmg').value);
    };

    // DRAGGABLE MENU
    dragElement(document.getElementById("admin-menu"));
    function dragElement(elmnt) {
        let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
        if (document.getElementById("admin-header")) {
            document.getElementById("admin-header").onmousedown = dragMouseDown;
            document.getElementById("admin-header").ontouchstart = dragTouchStart;
        }
        function dragMouseDown(e) {
            e = e || window.event; e.preventDefault();
            pos3 = e.clientX; pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
        }
        function elementDrag(e) {
            e = e || window.event; e.preventDefault();
            pos1 = pos3 - e.clientX; pos2 = pos4 - e.clientY;
            pos3 = e.clientX; pos4 = e.clientY;
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
        }
        function dragTouchStart(e) {
            const touch = e.touches[0];
            pos3 = touch.clientX; pos4 = touch.clientY;
            document.ontouchend = closeDragElement;
            document.ontouchmove = elementTouchDrag;
        }
        function elementTouchDrag(e) {
            const touch = e.touches[0];
            pos1 = pos3 - touch.clientX; pos2 = pos4 - touch.clientY;
            pos3 = touch.clientX; pos4 = touch.clientY;
            elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
            elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
        }
        function closeDragElement() {
            document.onmouseup = null; document.onmousemove = null;
            document.ontouchend = null; document.ontouchmove = null;
        }
    }

    // --- –ú–û–ë–ò–õ–¨–ù–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï ---
    let joystick = { active: false, dx: 0, dy: 0, originX: 0, originY: 0 };
    
    if (isMobile) {
        const jZone = document.getElementById('joystick-zone');
        const jKnob = document.getElementById('joystick-knob');
        
        jZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joystick.active = true;
            joystick.originX = touch.clientX; joystick.originY = touch.clientY;
            jZone.style.left = (touch.clientX - 50) + 'px'; jZone.style.bottom = 'auto'; jZone.style.top = (touch.clientY - 50) + 'px';
            jKnob.style.transform = `translate(0px, 0px)`;
        }, {passive: false});

        jZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!joystick.active) return;
            const touch = e.changedTouches[0];
            const maxDist = 35;
            let dx = touch.clientX - joystick.originX; let dy = touch.clientY - joystick.originY;
            let dist = Math.hypot(dx, dy);
            if (dist > maxDist) { dx = (dx / dist) * maxDist; dy = (dy / dist) * maxDist; }
            jKnob.style.transform = `translate(${dx}px, ${dy}px)`;
            joystick.dx = dx / maxDist; joystick.dy = dy / maxDist;
        }, {passive: false});

        jZone.addEventListener('touchend', (e) => {
            e.preventDefault();
            joystick.active = false; joystick.dx = 0; joystick.dy = 0;
            jKnob.style.transform = `translate(0px, 0px)`;
            jZone.style.left = '40px'; jZone.style.bottom = '90px'; jZone.style.top = 'auto';
        });

        const btnFire = document.getElementById('btn-fire');
        btnFire.addEventListener('touchstart', (e) => { e.preventDefault(); mouse.down = true; });
        btnFire.addEventListener('touchend', (e) => { e.preventDefault(); mouse.down = false; });
        
        document.getElementById('btn-reload').addEventListener('touchstart', (e) => { e.preventDefault(); reloadWeapon(); });
        document.getElementById('btn-bomb').addEventListener('touchstart', (e) => { e.preventDefault(); detonateBombs(); });
    }

    // --- –£–ü–†–ê–í–õ–ï–ù–ò–ï ---
    window.addEventListener('keydown', e => {
        if (isDemo && gameState === 'MENU') return; 
        keys[e.code] = true;
        if (e.code === 'Escape' && gameState !== 'MENU' && gameState !== 'GAMEOVER') togglePause();
        if (gameState === 'PLAYING') {
            if (!player.reloading) {
                let keyNum = parseInt(e.key);
                if (keyNum >= 1 && keyNum <= weapons.length) { selectWeapon(keyNum - 1); }
            }
            if (e.code === 'KeyR') reloadWeapon();
            if (e.code === 'KeyE') detonateBombs();
        }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);
    window.addEventListener('mousemove', e => { 
        if (isDemo || isMobile) return; 
        mouse.x = e.clientX; mouse.y = e.clientY; 
    });
    window.addEventListener('mousedown', (e) => { 
        // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å—Ç—Ä–µ–ª—å–±—É –ø—Ä–∏ –∫–ª–∏–∫–µ –Ω–∞ UI (hotbar/admin)
        if(e.target.closest('#hotbar-container') || e.target.closest('#admin-menu')) return;
        if (!isDemo && !isMobile) mouse.down = true; 
    });
    window.addEventListener('mouseup', () => { if (!isDemo && !isMobile) mouse.down = false; });

    document.getElementById('loadFileBtn').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) { try { loadGameData(JSON.parse(e.target.result)); } catch (err) { alert("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è!"); } };
        reader.readAsText(file);
    });

    window.toggleMap = function() {
        if (currentMapKey === 'METRO') currentMapKey = 'CITY';
        else currentMapKey = 'METRO';
        document.getElementById('map-btn').innerText = "–ö–ê–†–¢–ê: " + MAPS[currentMapKey].name;
    }

    window.togglePause = function() {
        if (gameState === 'PLAYING') { gameState = 'PAUSED'; document.getElementById('pauseMenu').classList.remove('hidden'); } 
        else if (gameState === 'PAUSED') { gameState = 'PLAYING'; document.getElementById('pauseMenu').classList.add('hidden'); }
    }

    window.saveGame = function() {
        try {
            const data = {
                mode: gameMode, map: currentMapKey,
                player: { x: player.x, y: player.y, hp: player.hp, maxHp: player.maxHp, wIdx: player.weaponIndex },
                weapons: weapons, score: score, wave: wave, kills: totalKills,
                enemies: enemies, items: items, bombs: placedBombs
            };
            const json = JSON.stringify(data);
            const blob = new Blob([json], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "metro_save_v402.json";
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
            alert("–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∫–∞—á–∞–Ω–æ!");
        } catch (e) {
            alert("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: " + e.message);
        }
    }

    window.triggerLoad = function() { document.getElementById('loadFileBtn').click(); }

    function loadGameData(data) {
        isDemo = false; gameMode = data.mode; currentMapKey = data.map || 'METRO';
        currentWalls = MAPS[currentMapKey].walls;
        player.x = data.player.x; player.y = data.player.y; player.hp = data.player.hp; player.maxHp = data.player.maxHp;
        weapons = data.weapons; player.weaponIndex = data.player.wIdx;
        score = data.score; wave = data.wave; totalKills = data.kills;
        enemies = data.enemies || []; items = data.items || []; placedBombs = data.bombs || [];
        bullets = []; particles = []; train.timer = 0; train.active = false; 
        gameState = 'PLAYING';
        createHotbar();
        document.getElementById('menu').classList.add('hidden'); document.getElementById('pauseMenu').classList.add('hidden');
        document.getElementById('gameOver').classList.add('hidden'); document.getElementById('ui').style.display = 'block';
        updateUI();
    }

    window.initGame = function(mode) {
        if (mode === 'DEMO') { isDemo = true; gameState = 'MENU'; } 
        else { isDemo = false; gameMode = mode; gameState = 'PLAYING'; document.getElementById('ui').style.display = 'block'; document.getElementById('menu').classList.add('hidden'); }
        currentWalls = MAPS[currentMapKey].walls;
        startGame();
    }

    window.startGame = function() {
        let spawn = MAPS[currentMapKey].spawn;
        player.x = spawn.x; player.y = spawn.y;
        player.hp = 100; player.maxHp = 100;
        score = 0; wave = 1; totalKills = 0; player.reloading = false;
        bullets = []; enemies = []; particles = []; items = []; placedBombs = []; train.timer = 0; train.active = false;
        
        if (gameMode === 'FISTS') { weapons = [ JSON.parse(JSON.stringify(ALL_WEAPONS[2])) ]; player.weaponIndex = 0; } 
        else { weapons = JSON.parse(JSON.stringify(ALL_WEAPONS)); player.weaponIndex = isDemo ? 4 : 2; if (isDemo) weapons[4].ammo = Infinity; }
        
        if (gameMode === 'HARDCORE') { player.hp = 1; player.maxHp = 1; }
        if (!isDemo) { document.getElementById('gameOver').classList.add('hidden'); document.getElementById('victory').classList.add('hidden'); }
        if (gameMode === '100_ENEMIES') { document.getElementById('wave-ui').classList.add('hidden'); document.getElementById('goal-ui').classList.remove('hidden'); } 
        else { document.getElementById('wave-ui').classList.remove('hidden'); document.getElementById('goal-ui').classList.add('hidden'); }
        
        createHotbar();
        spawnWave();
    }

    function createHotbar() {
        const hb = document.getElementById('hotbar-container');
        hb.innerHTML = '';
        weapons.forEach((w, idx) => {
            let d = document.createElement('div');
            d.className = 'slot';
            if (idx === player.weaponIndex) d.classList.add('active');
            d.innerHTML = `<span class="slot-num">${idx+1}</span><span style="font-size:20px">${w.icon || '?'}</span><span class="slot-ammo" id="slot-ammo-${idx}">${w.ammo === Infinity ? '‚àû' : w.ammo}</span>`;
            d.onclick = () => selectWeapon(idx);
            hb.appendChild(d);
        });
    }

    function selectWeapon(idx) {
        if (idx < 0 || idx >= weapons.length) return;
        player.weaponIndex = idx;
        updateUI();
    }

    function detonateBombs() {
        if (placedBombs.length === 0) return;
        placedBombs.forEach(b => {
            spawnParticles(b.x, b.y, 50, 'orange');
            enemies.forEach(e => {
                let dist = Math.hypot(e.x - b.x, e.y - b.y);
                if (dist < b.range) { e.hp -= b.dmg; e.vx += (e.x - b.x)/dist * 20; e.vy += (e.y - b.y)/dist * 20; spawnParticles(e.x, e.y, 10, 'black'); }
            });
        });
        placedBombs = [];
    }

    function spawnWave() {
        let count = 5 + wave * 2;
        if (gameMode === '100_ENEMIES') count = 8 + wave * 3;
        for (let i = 0; i < count; i++) spawnEnemy();
    }

    function checkWallCollision(x, y, r) {
        for (let w of currentWalls) {
            let cx = Math.max(w.x, Math.min(x, w.x + w.w));
            let cy = Math.max(w.y, Math.min(y, w.y + w.h));
            let dx = x - cx; let dy = y - cy;
            if ((dx * dx + dy * dy) < (r * r)) return true;
        }
        return false;
    }

    function spawnEnemy() {
        if (gameMode === '100_ENEMIES' && (enemies.length + totalKills) >= 100) return;
        let sx, sy, valid = false, att = 0;
        while (!valid && att < 50) {
            att++; sx = Math.random() * (WORLD_W-100)+50; sy = Math.random() * (WORLD_H-100)+50;
            if (!checkWallCollision(sx, sy, 40) && !(currentMapKey === 'METRO' && sy > train.y - 50 && sy < train.y + train.height + 50)) {
                if (Math.hypot(sx - player.x, sy - player.y) > 500) valid = true;
            }
        }
        if (!valid) return;
        let r = Math.random();
        let e = { x: sx, y: sy, vx: 0, vy: 0 };
        if (r > 0.85) { e.c='#0c0'; e.s=2; e.hp=120; e.r=25; e.dmg=0.8; }
        else if (r > 0.65) { e.c='#f00'; e.s=5.5; e.hp=25; e.r=14; e.dmg=0.4; }
        else { e.c='#a0a'; e.s=3.5; e.hp=45; e.r=18; e.dmg=0.5; }
        e.maxHp = e.hp;
        enemies.push(e);
    }

    function spawnItem() {
        if (items.length >= 6) return;
        let ix, iy, valid = false, att = 0;
        while (!valid && att < 50) {
            att++; ix = Math.random()*(WORLD_W-100)+50; iy = Math.random()*(WORLD_H-100)+50;
            if (!checkWallCollision(ix, iy, 30)) valid = true;
        }
        if (!valid) return;
        let rand = Math.random();
        let type = 'ammo';
        if (gameMode !== 'HARDCORE' && rand > 0.6) type = 'health';
        if (rand > 0.9 && gameMode !== 'FISTS') type = 'c4';
        items.push({ x: ix, y: iy, type: type, size: 25 });
    }

    function reloadWeapon() {
        let w = weapons[player.weaponIndex];
        if (w.type === 'placeable' || w.ammo === Infinity) return;
        if (w.ammo < w.max && !player.reloading) { player.reloading = true; player.reloadMax = w.rld; player.reloadTimer = w.rld; }
    }

    function update() {
        if (!isDemo && gameMode === '100_ENEMIES' && totalKills >= 100) { gameState = 'VICTORY'; document.getElementById('victory').classList.remove('hidden'); document.getElementById('ui').style.display = 'none'; return; }
        
        if (hitEffectTimer > 0) {
            hitEffectTimer--;
            document.getElementById('blood-screen').style.opacity = 0.8;
        } else if (player.hp < 30) {
            let opacity = (30 - player.hp) / 30;
            document.getElementById('blood-screen').style.opacity = opacity;
        } else {
            document.getElementById('blood-screen').style.opacity = 0;
        }

        if (player.hp <= 0 && !godMode) {
            if (isDemo) { startGame(); return; }
            gameState = 'GAMEOVER'; document.getElementById('final-kills').innerText = totalKills; document.getElementById('gameOver').classList.remove('hidden'); document.getElementById('ui').style.display = 'none'; return;
        }

        if (frame % 400 === 0) spawnItem();

        // –ö–õ–û–ù –õ–û–ì–ò–ö–ê
        if (clone.active) {
            let nearestE = null; let minD = 500;
            enemies.forEach(e => { let d = Math.hypot(e.x - clone.x, e.y - clone.y); if (d < minD) { minD = d; nearestE = e; } });
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –∫–ª–æ–Ω–∞
            let tx = nearestE ? nearestE.x : player.x;
            let ty = nearestE ? nearestE.y : player.y;
            let targetDist = Math.hypot(tx - clone.x, ty - clone.y);
            
            if (targetDist > 60) {
                let ca = Math.atan2(ty - clone.y, tx - clone.x);
                let cx = Math.cos(ca)*4; let cy = Math.sin(ca)*4;
                if (!checkWallCollision(clone.x+cx, clone.y, 20)) clone.x += cx;
                if (!checkWallCollision(clone.x, clone.y+cy, 20)) clone.y += cy;
            }
            // –°—Ç—Ä–µ–ª—å–±–∞ –∫–ª–æ–Ω–∞
            if (nearestE && minD < 300) {
                clone.timer++;
                if (clone.timer > 20) {
                    clone.timer = 0;
                    bullets.push({ x: clone.x, y: clone.y, vx: (nearestE.x - clone.x)/minD * 10, vy: (nearestE.y - clone.y)/minD * 10, dmg: clone.dmg, range: 400, dist: 0, col: clone.col });
                }
            }
        }

        let dx = 0, dy = 0;

        if (isDemo) {
            let nearest = null; let minDist = Infinity;
            enemies.forEach(e => { let d = Math.hypot(e.x - player.x, e.y - player.y); if (d < minDist) { minDist = d; nearest = e; } });
            if (nearest) {
                player.angle = Math.atan2(nearest.y - player.y, nearest.x - player.x); mouse.down = true;
                if (minDist > 400) { dx = Math.cos(player.angle); dy = Math.sin(player.angle); } 
                else if (minDist < 200) { dx = -Math.cos(player.angle); dy = -Math.sin(player.angle); } 
                else { dx = Math.cos(player.angle + Math.PI/2); dy = Math.sin(player.angle + Math.PI/2); }
            } else { mouse.down = false; player.angle += 0.05; }
        } else {
            if (isMobile) {
                dx = joystick.dx; dy = joystick.dy;
                let nearest = null; let minDist = 1000; 
                enemies.forEach(e => { let d = Math.hypot(e.x - player.x, e.y - player.y); if (d < minDist) { minDist = d; nearest = e; } });
                if (nearest) { player.angle = Math.atan2(nearest.y - player.y, nearest.x - player.x); } 
                else if (joystick.active) { if (Math.hypot(dx, dy) > 0.1) player.angle = Math.atan2(dy, dx); }
            } else {
                if (keys['KeyW']) dy = -1; if (keys['KeyS']) dy = 1; if (keys['KeyA']) dx = -1; if (keys['KeyD']) dx = 1;
                let mx = mouse.x; let my = mouse.y;
                camera.x = Math.max(0, Math.min(player.x - canvas.width/2, WORLD_W - canvas.width));
                camera.y = Math.max(0, Math.min(player.y - canvas.height/2, WORLD_H - canvas.height));
                player.angle = Math.atan2((my + camera.y) - player.y, (mx + camera.x) - player.x);
            }
        }

        if (dx || dy) {
            let l = Math.hypot(dx, dy);
            if (l > 1) l = 1; 
            if (isMobile) {
                 let speed = player.speed;
                 if(!checkWallCollision(player.x+dx*speed, player.y, player.radius)) player.x += dx*speed;
                 if(!checkWallCollision(player.x, player.y+dy*speed, player.radius)) player.y += dy*speed;
            } else {
                 if(l > 0) {
                    let mx = (dx/l)*player.speed; let my = (dy/l)*player.speed;
                    if (!checkWallCollision(player.x+mx, player.y, player.radius)) player.x += mx;
                    if (!checkWallCollision(player.x, player.y+my, player.radius)) player.y += my;
                 }
            }
        }

        let visibleW = canvas.width / mobileScale;
        let visibleH = canvas.height / mobileScale;
        camera.x = Math.max(0, Math.min(player.x - visibleW/2, WORLD_W - visibleW));
        camera.y = Math.max(0, Math.min(player.y - visibleH/2, WORLD_H - visibleH));

        if (player.reloading) { player.reloadTimer--; if (player.reloadTimer <= 0) { weapons[player.weaponIndex].ammo = weapons[player.weaponIndex].max; player.reloading = false; updateUI(); } }

        for (let i = items.length - 1; i >= 0; i--) {
            let it = items[i];
            if (Math.hypot(player.x - it.x, player.y - it.y) < player.radius + it.size) {
                let picked = false;
                if (it.type === 'health' && player.hp < player.maxHp) { player.hp = Math.min(player.maxHp, player.hp+30); spawnParticles(player.x, player.y, 10, '#0f0'); picked = true; }
                else if (it.type === 'ammo') { let w = weapons[player.weaponIndex]; if (w.type !== 'placeable' && w.ammo !== Infinity && w.ammo < w.max) { w.ammo = w.max; spawnParticles(player.x, player.y, 10, '#ff0'); picked = true; } }
                else if (it.type === 'c4') { let c4 = weapons.find(w => w.name === "C4 –ë–û–ú–ë–ê"); if (c4) { c4.ammo = Math.min(c4.ammo + 2, c4.max); spawnParticles(player.x, player.y, 10, '#f00'); picked = true; } }
                if (picked) { items.splice(i, 1); updateUI(); }
            }
        }

        let w = weapons[player.weaponIndex];
        if (w.ammo <= 0 && w.ammo !== Infinity && !player.reloading && w.type !== 'placeable') reloadWeapon();

        if (mouse.down && !player.reloading && w.ammo > 0 && frame % w.delay === 0) {
            if (w.ammo !== Infinity) w.ammo--;
            if (w.type === 'placeable') { placedBombs.push({ x: player.x, y: player.y, dmg: w.dmg, range: w.range }); } 
            else if (w.type === 'melee') {
                // –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê –ë–õ–ò–ñ–ù–ï–ì–û –ë–û–Ø (Hitbox + Particle Swipe)
                // –†–∏—Å—É–µ–º —ç—Ñ—Ñ–µ–∫—Ç –≤–∑–º–∞—Ö–∞
                for(let k=0; k<5; k++) {
                   let swA = player.angle - 0.5 + Math.random();
                   particles.push({x: player.x, y: player.y, vx: Math.cos(swA)*6, vy: Math.sin(swA)*6, life: 10, size: 2, color: '#fff'});
                }
                enemies.forEach(e => {
                    let d = Math.hypot(e.x - player.x, e.y - player.y);
                    if (d < w.range + e.r) {
                        // –ë–æ–ª–µ–µ —â–∞–¥—è—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —É–≥–ª–∞ –¥–ª—è –±–ª–∏–∂–Ω–µ–≥–æ –±–æ—è
                        let angToE = Math.atan2(e.y - player.y, e.x - player.x);
                        let diff = Math.abs(angToE - player.angle);
                        if (diff > Math.PI) diff = 2*Math.PI - diff;
                        
                        if (diff < 1.0 || d < e.r + 10) { // –ï—Å–ª–∏ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ - –±—å–µ–º –≤—Å–µ–≥–¥–∞
                            e.hp -= w.dmg; 
                            e.vx += Math.cos(player.angle)*15; e.vy += Math.sin(player.angle)*15; 
                            spawnParticles(e.x, e.y, 5, '#fff'); 
                        }
                    }
                });
            }
            else if (w.type === 'gun') {
                shake = 5;
                for (let i = 0; i < w.count; i++) {
                    let s = (Math.random()-0.5)*w.spread;
                    bullets.push({ x: player.x + Math.cos(player.angle)*25, y: player.y + Math.sin(player.angle)*25, vx: Math.cos(player.angle+s)*18, vy: Math.sin(player.angle+s)*18, dmg: w.dmg, range: w.range, dist: 0, col: w.col });
                }
            } 
            updateUI();
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; b.x += b.vx; b.y += b.vy; b.dist += Math.hypot(b.vx, b.vy);
            let hit = false;
            if (b.dist > b.range || checkWallCollision(b.x, b.y, 2)) hit = true;
            else { for (let j = enemies.length - 1; j >= 0; j--) { let e = enemies[j]; if (Math.hypot(b.x - e.x, b.y - e.y) < e.r + 5) { e.hp -= b.dmg; e.vx += b.vx*0.1; e.vy += b.vy*0.1; spawnParticles(e.x, e.y, 2, '#000'); hit = true; break; } } }
            if (hit) bullets.splice(i, 1);
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i]; let ang = Math.atan2(player.y - e.y, player.x - e.x); e.vx += Math.cos(ang)*0.3; e.vy += Math.sin(ang)*0.3; e.vx *= 0.9; e.vy *= 0.9;
            let s = Math.hypot(e.vx, e.vy); if (s > e.s) { e.vx = (e.vx/s)*e.s; e.vy = (e.vy/s)*e.s; }
            if (!checkWallCollision(e.x+e.vx, e.y, e.r)) e.x += e.vx; else e.vx *= -0.5;
            if (!checkWallCollision(e.x, e.y+e.vy, e.r)) e.y += e.vy; else e.vy *= -0.5;
            let distP = Math.hypot(player.x - e.x, player.y - e.y); let minP = player.radius + e.r;
            if (distP < minP) {
                let ov = minP - distP; let dx = player.x - e.x, dy = player.y - e.y;
                e.x -= (dx/distP)*ov*0.8; e.y -= (dy/distP)*ov*0.8;
                if(!checkWallCollision(player.x+(dx/distP)*2, player.y, player.radius)) player.x += (dx/distP)*2;
                if(!checkWallCollision(player.x, player.y+(dy/distP)*2, player.radius)) player.y += (dy/distP)*2;
                if(!godMode) {
                    player.hp -= e.dmg; 
                    hitEffectTimer = 10; 
                    updateUI();
                }
            }
            for (let j = i - 1; j >= 0; j--) { let e2 = enemies[j]; let d2 = Math.hypot(e.x - e2.x, e.y - e2.y); let m2 = e.r + e2.r; if (d2 < m2 && d2 > 0) { let ov = m2 - d2; let dx2 = e.x - e2.x, dy2 = e.y - e2.y; e.x += (dx2/d2)*ov*0.4; e.y += (dy2/d2)*ov*0.4; e2.x -= (dx2/d2)*ov*0.4; e2.y -= (dy2/d2)*ov*0.4; } }
            if (e.hp <= 0) { score += 15; totalKills++; spawnParticles(e.x, e.y, 15, '#000'); enemies.splice(i, 1); updateUI(); }
        }

        if (enemies.length === 0 && train.timer < 500) { wave++; spawnWave(); updateUI(); }
        
        if (currentMapKey === 'METRO') {
            train.timer++;
            if (train.timer > 1000) { if (!train.warning) train.warning = true; if (train.timer > 1200 && !train.active) { train.active = true; train.warning = false; train.x = -3000; } }
            if (train.active) {
                train.x += train.speed; let tx = train.x, ty = train.y, tw = 4000, th = train.height;
                if (player.x > tx && player.x < tx+tw && player.y > ty && player.y < ty+th && !godMode) { player.hp = 0; spawnParticles(player.x, player.y, 50, 'red'); }
                enemies.forEach(e => { if (e.x > tx && e.x < tx+tw && e.y > ty && e.y < ty+th) { e.hp = -999; spawnParticles(e.x, e.y, 20, '#000'); } });
                if (train.x > WORLD_W + 1000) { train.active = false; train.timer = 0; }
            }
        }

        for (let i = particles.length - 1; i >= 0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life--; if (p.life <= 0) particles.splice(i, 1); }
        frame++;
    }

    function spawnParticles(x, y, n, c) { for(let i=0; i<n; i++) particles.push({ x: x, y: y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 30+Math.random()*30, size: Math.random()*5+2, color: c }); }

    let shake = 0;
    function draw() {
        ctx.fillStyle = MAPS[currentMapKey].bg; 
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.save();
        ctx.scale(mobileScale, mobileScale);
        if (shake > 0) { ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); shake *= 0.9; }
        ctx.translate(-camera.x, -camera.y);

        if (MAPS[currentMapKey].ground) {
            MAPS[currentMapKey].ground.forEach(g => {
                ctx.fillStyle = g.c;
                ctx.fillRect(g.x, g.y, g.w, g.h);
            });
        }

        ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
        if(currentMapKey === 'METRO') {
            for(let xx=0; xx<WORLD_W; xx+=100) { ctx.beginPath(); ctx.moveTo(xx,0); ctx.lineTo(xx,WORLD_H); ctx.stroke(); }
            for(let yy=0; yy<WORLD_H; yy+=100) { ctx.beginPath(); ctx.moveTo(0,yy); ctx.lineTo(WORLD_W,yy); ctx.stroke(); }
        }

        if (currentMapKey === 'METRO') {
            let ty = train.y;
            if (train.warning && frame % 15 < 8) { ctx.fillStyle = 'rgba(200,0,0,0.3)'; ctx.fillRect(0, ty, WORLD_W, train.height); }
            ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, ty+10, WORLD_W, train.height-20);
            ctx.strokeStyle = '#666'; ctx.lineWidth = 6;
            ctx.beginPath(); ctx.moveTo(0, ty+20); ctx.lineTo(WORLD_W, ty+20); ctx.moveTo(0, ty+train.height-20); ctx.lineTo(WORLD_W, ty+train.height-20); ctx.stroke();
        }

        particles.forEach(p => { ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, p.size, p.size); });
        placedBombs.forEach(b => { ctx.fillStyle = '#f00'; let pulse = Math.sin(frame * 0.2) * 5; ctx.fillRect(b.x - 10 - pulse/2, b.y - 10 - pulse/2, 20+pulse, 20+pulse); ctx.strokeStyle = 'yellow'; ctx.strokeRect(b.x - 10 - pulse/2, b.y - 10 - pulse/2, 20+pulse, 20+pulse); });
        
        items.forEach(it => {
            let s = 1 + Math.sin(frame * 0.1) * 0.1; let cx = it.x - (it.size * s)/2, cy = it.y - (it.size * s)/2;
            if (it.type === 'health') { ctx.fillStyle = 'green'; ctx.fillRect(cx, cy, it.size*s, it.size*s); ctx.fillStyle = 'white'; ctx.fillRect(cx+8, cy+2, 8, 20); ctx.fillRect(cx+2, cy+8, 20, 8); }
            else if (it.type === 'ammo') { ctx.fillStyle = '#cc0'; ctx.fillRect(cx, cy, it.size*s, it.size*s); ctx.fillStyle = 'black'; ctx.fillRect(cx+5, cy+5, 5, 15); ctx.fillRect(cx+15, cy+5, 5, 15); }
            else if (it.type === 'c4') { ctx.fillStyle = '#a00'; ctx.fillRect(cx, cy, it.size*s, it.size*s); ctx.fillStyle = '#f00'; ctx.font = "20px Courier"; ctx.fillText("C4", cx+2, cy+18); }
        });

        ctx.strokeStyle = '#000'; ctx.lineWidth = 2; 
        currentWalls.forEach(w => { ctx.fillStyle = w.c; ctx.fillRect(w.x, w.y, w.w, w.h); ctx.strokeRect(w.x, w.y, w.w, w.h); });
        
        if (currentMapKey === 'METRO' && train.active) { ctx.fillStyle = '#334'; ctx.fillRect(train.x, train.y+10, 4000, train.height-20); ctx.fillStyle = '#fea'; ctx.fillRect(train.x+3950, train.y+30, 50, train.height-60); }
        
        enemies.forEach(e => { 
            ctx.fillStyle = e.c; ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI*2); ctx.fill(); ctx.stroke(); 
            ctx.fillStyle = 'red'; ctx.fillRect(e.x - 15, e.y - e.r - 10, 30, 4);
            ctx.fillStyle = '#0f0'; ctx.fillRect(e.x - 15, e.y - e.r - 10, 30 * (e.hp/e.maxHp), 4);
        });

        // –û–¢–†–ò–°–û–í–ö–ê –ö–õ–û–ù–ê
        if (clone.active) {
            ctx.fillStyle = clone.col; ctx.beginPath(); ctx.arc(clone.x, clone.y, 20, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = 'white'; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = 'white'; ctx.font = "10px Courier"; ctx.fillText("CLONE", clone.x-15, clone.y-25);
        }

        if (adminEsp) {
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; ctx.lineWidth = 1;
            enemies.forEach(e => {
                ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(e.x, e.y); ctx.stroke();
            });
        }

        ctx.save(); ctx.translate(player.x, player.y);
        if (player.reloading) { ctx.fillStyle = 'red'; ctx.fillRect(-20, -35, 40, 5); ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -35, 40*(1 - player.reloadTimer/player.reloadMax), 5); }
        ctx.rotate(player.angle); ctx.fillStyle = godMode ? '#ff0' : '#369'; ctx.beginPath(); ctx.arc(0, 0, player.radius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = weapons[player.weaponIndex].col; ctx.fillRect(0, -5, 25, 10); ctx.restore();
        bullets.forEach(b => { ctx.fillStyle = b.col; ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill(); });
        ctx.restore();
    }

    function updateUI() {
        document.getElementById('hp-val').innerText = Math.floor(player.hp);
        document.getElementById('wave-val').innerText = wave;
        document.getElementById('kill-val').innerText = totalKills;
        document.getElementById('enemies-left').innerText = enemies.length;
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–ª–æ—Ç–æ–≤ (–ø–∞—Ç—Ä–æ–Ω—ã)
        document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
        let slots = document.querySelectorAll('.slot');
        if (slots[player.weaponIndex]) slots[player.weaponIndex].classList.add('active');
        
        weapons.forEach((w, i) => {
            let am = document.getElementById(`slot-ammo-${i}`);
            if (am) {
                am.innerText = w.ammo === Infinity ? '‚àû' : w.ammo;
                am.style.color = (w.ammo === 0 && w.ammo !== Infinity) ? 'red' : '#ff0';
            }
        });
    }

    initGame('DEMO');
    function loop() { if (gameState === 'PLAYING' || (gameState === 'MENU' && isDemo)) { update(); draw(); } requestAnimationFrame(loop); }
    loop(); 
};
</script>
</body>
</html>
